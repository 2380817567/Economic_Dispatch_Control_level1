%看这个代码的时候可能还是要回去找视频，因为你其实是对着电路图编这个代码的，所以一定要边看图边理解
%跑不了啊，到底是哪里出问题了？
%应该就这样了   一个问题是以后尽量不要使用global去声明变量     还有一个我感觉有可能是因为求解器不同，所以算出来的值似乎不太一样呢？

clc;clear
% 参数设置
Gen= [1 2 1 700 0 200 -200 0 10 5;
      2 6 1 400 0 200 -200 0 11 6;
      3 1 1 200 0 55 -55 0 14 7;
      4 2 1 60 0 25 -25 0 20 8;
      5 6 1 30 0 10 -10  0 -25 9;
     ];
%每一列分别表示发电机编号，发电机节点号，发电机类型（1为火电机组，2为燃气机组）
 %发电机出力上限，发电机出力下限、发电机上爬坡能力、发电机下爬坡能力，8,9列是成本系数，10列是备用成本单位
T = 24;
NG=size(Gen,1);  %发电机个数
Branch = [ 1 1 2  0.005 0.17 10e7;
           2 2 3 0 0.037 10e7;
           3 4 5 0 0.037 10e7;
           4 6 5 0.002 0.14 10e7;
           5 1 4 0.003 0.258 10e7;
           6 3 6 0.0005 0.018 10e7;
           7 2 4 0.007 0.197 10e7;
         ];%每一列分别表示线路编号，起始节点，终止节点，线路电阻，线路电抗，线路潮流上限
NB=size(Branch,1); %支路个数
Load=[1 3 0.4;
      2 4 0.3;
      3 5 0.3;
    ];%每一列分别表示负荷编号，负荷节点号，负荷占比；
TotalLoad=[175.2 165.2 158.7 154.7 155.0 160.5 173.4 190.4 205.6 217.2 228.6 236.1 238.2 243.6 248.9 255.8 256 246.7 246.0 237.4 237.3 227.1 201.1 196.8]*3;  %负荷大小
rate = 0.15;  %百分之15的备用率
NL = size(Load,1);  %表示负荷个数
N=6; %定义节点个数



%求GSF矩阵
y1 = 1/(0.005+0.17j);
y2 = 1/(0.037j);
y3 = 1/(0.037j);
y4 = 1/(0.002+0.14j);
y5 = 1/(0.003+0.258j);
y6 = 1/(0.0005+0.018j);
y7 = 1/(0.007+0.197j);
%形成节点导纳矩阵
%这个矩阵比较小，所以就直接把导纳矩阵写出来了，但是如果遇到庞大节点的矩阵，这个地方是需要写循环把矩阵求出来的
Y = [y1+y5 -y1 0 -y5 0 0;
     -y1 y1+y2+y7 -y2 -y7 0 0;
     0 -y2 y2+y6 0 0 -y6;
     -y5 -y7 0 y3+y5+y7 -y3 0;
     0 0 0 -y3 y3+y4 -y4;
     0 0 -y6 0 -y4 y4+y6;
    ];
%形成节点阻抗矩阵
Z = inv(Y);
%形成GSF矩阵
for k=1:NB
    for i=1:N
        GSF(k,i)=(1/Branch(k,5))*(imag(Z(i,Branch(k,2)))-imag(Z(i,Branch(k,3))));   %Branch的第二列是起点节点，第三列是终点节点
    end
end    
%%      %%%%%决策变量定义
G = sdpvar(NG,T);  %NG是发电机个数，T表示多时段
R = sdpvar(NG,T);
%% %%%%%约束定义
%global f1
f1 = [];
for t = 1:T
    f1 = [f1,sum(G(:,t))-TotalLoad(t) == 0];
end

%global f2
f2 = [];
for t = 1:T
  for k = 1:NB
    f2 = [f2,sum(GSF(k,Gen(:,2))'.*G(:,t)) - sum(GSF(k,Load(:,2))'.*Load(:,3)*TotalLoad(t))<=Branch(k,6)];
    %f2 = [f2,sum(GSF(k,:)'.*(G(:,t)-TotalLoad(t)*Load(:,2))) <= Branch(k,6)];      %% 这里有点问题
    % '表示转置，矩阵.*得到一个数值，但矩阵*会得到一个矩阵
    %这里想要理解还得去看原视频，这个是按着公式编的，你得对着公式才能理解这个式子。
  end
end

%global f3
f3 = [];
for i = 1:NG
    for t = 1:T
      f3 = [f3,Gen(i,5)<=G(i,t)+R(i,t)<=Gen(i,4)];
      f3 = [f3,G(i,t)>=Gen(i,5)];
      f3 = [f3,R(i,t)>=0];
    end
end

%global f4    %爬坡约束
f4 = [];
for t = 2:T
    for i = 1:NG
        f4 = [f4,G(i,t)-G(i,t-1)<=Gen(i,6)];
        f4 = [f4,G(i,t)-G(i,t-1)>=Gen(i,7)];
    end
end

% global f5
f5 = [];
for t = 1:T
    f5 = [f5,sum(R(:,t))>=rate*TotalLoad(t)];
end

F = f1+f2+f3+f4+f5;

%% 目标函数
Cost = 0;
for t = 1:T
    for i = 1:NG
        Cost = Cost + Gen(i,9)*G(i,t)+Gen(i,10)*R(i,t);
    end
end

%%  求解设置
ops = sdpsettings('solver','gurobi');
sol = solvesdp(F,Cost,ops);
%% 输出变量设置
G = value(G);
R = value(R);
Cost = value(Cost);













